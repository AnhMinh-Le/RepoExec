{"task_id": 194, "prediction_id": 0, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_lines = []  # type: T.List[str]\n    param_args = []  # type: T.List[str]\n    param_desc = []  # type: T.List[str]\n    param_type_name = None  # type: T.Optional[str]\n    param_is_optional = None  # type: T.Optional[bool]\n    param_default = None  # type: T.Optional[str]\n    param_arg_name = None  # type: T.Optional[str]\n    param_description = None  # type: T.Optional[str]\n    param_type_name_arg_name = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_description = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_is_generator = None  # type: T.Optional[bool]\n    param_type_name_arg_name_optional_default_is_generator_description = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_is_generator_description_is_generator = None  # type: T.Optional[bool]\n    param_type_name_arg_name_optional_default_is_generator_description_is_generator_description_is_generator_default = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_is_generator_description_is_generator_description_is_generator_description_is_generator_default_description = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_is_generator_description_is_generator_description_", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 138, in <module>\n  File \"<string>\", line 137, in test_21\n  File \"<string>\", line 132, in parse\nNameError: name 'param_type_name_arg_name_optional_default_is_generator_description_is_generator_description_' is not defined\n", "passed": false}
{"task_id": 194, "prediction_id": 1, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    description = None  # type: T.Optional[str]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if description is not None:\n                meta.append(DocstringMeta(args=[], description=description))\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[], description=short_description))\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[], description=long_description))\n            if blank_after_short_description:\n                meta.append(DocstringMeta(args=[], description=description))\n            if blank_after_long_description:\n                meta.append(DocstringMeta(args=[], description=long_description))\n            blank_after_short_description = False\n            blank_after_long_description = False\n            continue\n        if line.startswith(\".. \"):\n            if description is not None:\n                meta.append(DocstringMeta(args=[], description=description))\n            description = line[3:].strip()\n            continue\n        if line.startswith(\".. \") and description is None:\n            raise ParseError(\"No description found.\")\n        if line.startswith(\".. \"):\n            if description is not None:\n                meta.append(DocstringMeta(args=[], description=description))\n            description = line[3:].strip()\n            continue\n        if description is not None:\n            if line.startswith(\"    \"):\n                if short_description is None:\n                    short_description = description\n                description = None\n                continue\n            if line.startswith(\"    \"):\n                if long_description is None:\n                    long_description = description\n                description = None\n                continue\n            if description is None:\n                raise ParseError(\"No description found.\")", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 166, in <module>\n  File \"<string>\", line 165, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 2, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if blank_after_short_description:\n                blank_after_short_description = False\n                continue\n            if blank_after_long_description:\n                blank_after_long_description = False\n                continue\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Found a short description after a long description.\"\n                )\n            short_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Found a long description after a short description.\"\n                )\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a short description.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a long description.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a short description.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a long description.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a short description.\"\n            )\n        if line.startswith(\".. \"):\n            raise Parse", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 173, in <module>\n  File \"<string>\", line 172, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 3, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_lines = []  # type: T.List[str]\n    param_args = []  # type: T.List[str]\n    param_desc = []  # type: T.List[str]\n    param_type = None  # type: T.Optional[str]\n    param_is_optional = None  # type: T.Optional[bool]\n    param_default = None  # type: T.Optional[str]\n    param_arg_name = None  # type: T.Optional[str]\n    param_type_name = None  # type: T.Optional[str]\n    param_is_generator = False  # type: T.Optional[bool]\n    param_is_raises = False  # type: T.Optional[bool]\n    param_is_deprecated = False  # type: T.Optional[bool]\n    param_is_raises_or_deprecated = False  # type: T.Optional[bool]\n    param_is_raises_or_deprecated_or_generator = False  # type: T.Optional[bool]\n    param_is_raises_or_deprecated_or_generator_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_deprecated_or_generator_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_deprecated_or_generator_or_optional_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_deprecated_or_generator_or_optional_or_optional_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_deprecated_or_generator_or_optional_or_optional_or_optional_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_deprecated_or_generator_", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 139, in <module>\n  File \"<string>\", line 138, in test_21\n  File \"<string>\", line 133, in parse\nNameError: name 'param_is_raises_or_deprecated_or_generator_' is not defined\n", "passed": false}
{"task_id": 194, "prediction_id": 4, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"short_description\"], description=short_description))\n                short_description = None\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"long_description\"], description=long_description))\n                long_description = None\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"long_description\"], description=long_description))\n                long_description = None\n            long_description = line[3:].strip()\n        elif line.startswith(\" \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"short_description\"], description=short_description))\n                short_description = None\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"long_description\"], description=long_description))\n                long_description = None\n            if blank_after_short_description:\n                meta.append(DocstringMeta(args=[\"blank_after_short_description\"], description=\"\"))\n                blank_after_short_description = False\n            if blank_after_long_description:\n                meta.append(DocstringMeta(args=[\"blank_after_long_description\"], description=\"\"))\n                blank_after_long_description = False\n        elif line.startswith(\" \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"short_description\"], description=short_description))\n                short_description = None\n            if long_description is not", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 151\n    if long_description is not\n                              ^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 194, "prediction_id": 5, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if not lines:\n        return Docstring()\n    short_description = None\n    long_description = None\n    meta = []  # type: T.List[DocstringMeta]\n    for line in lines:\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"short_description\"], description=short_description))\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"long_description\"], description=long_description))\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is None:\n            raise ParseError(\"Expected a short description after the first '.. '.\")\n        elif line.startswith(\".. \") and long_description is None:\n            raise ParseError(\"Expected a long description after the first '.. '.\")\n        elif line.startswith(\".. \") and short_description is not None:\n            meta.append(_build_meta(line[3:].split(), short_description))\n            short_description = None\n        elif line.startswith(\".. \") and long_description is not None:\n            meta.append(_build_meta(line[3:].split(), long_description))\n            long_description = None\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Expected a description after the first '.. '.\")\n        elif line.startswith(\".. \") and short_description is None:\n            raise ParseError(\"Expected a short description after the first '.. '.\")\n        elif line.startswith(\".. \") and long_description is None:\n            raise ParseError(\"Expected a long description after the first '.. '.\")\n        elif line.startswith(\".. \") and short_description is not None:\n            meta.append(_build_meta(line[3:].split(), short_description))\n            short_description = None\n        ", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 153, in <module>\n  File \"<string>\", line 152, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 6, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if not lines:\n        return Docstring()\n    short_description = None\n    long_description = None\n    meta = []\n    for line in lines:\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=short_description.args, description=short_description.description))\n            short_description = _build_meta(line[3:].split(), \"short description\")\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=long_description.args, description=long_description.description))\n            long_description = _build_meta(line[3:].split(), \"long description\")\n        elif line.startswith(\".. \") and short_description is None:\n            raise ParseError(\"Expected a short description after an '.. '.\")\n        elif line.startswith(\".. \") and long_description is None:\n            raise ParseError(\"Expected a long description after an '.. '.\")\n        elif line.startswith(\".. \") and short_description is not None and long_description is not None:\n            raise ParseError(\"Expected either a short description or a long description after an '.. '.\")\n        elif line.startswith(\".. \"):\n            continue\n        elif line.startswith(\"    \"):\n            meta.append(_build_meta(line[4:].split(), \"description\"))\n        elif line.startswith(\"    \"):\n            meta.append(_build_meta(line[4:].split(), \"arg_name\"))\n        elif line.startswith(\"    \"):\n            meta.append(_build_meta(line[4:].split(), \"type_name\"))\n        elif line.startswith(\"    \"):\n            meta.append(_build_meta(line[4:].split(), \"is_optional\"))\n        elif line.startswith(\"    \"):\n            meta.append(_build_meta(line[4:].split(), \"default\"))\n        elif line.startswith(\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 146\n    elif line.startswith(\"\n                         ^\nSyntaxError: unterminated string literal (detected at line 146)\n", "passed": false}
{"task_id": 194, "prediction_id": 7, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                if long_description is not None:\n                    raise ParseError(\n                        \"Docstring has both short and long description.\"\n                    )\n                long_description = short_description\n                short_description = None\n            if long_description is None:\n                long_description = line[3:].strip()\n            else:\n                if line.startswith(\" \"):\n                    long_description += \" \" + line[3:].strip()\n                else:\n                    long_description += \"\\n\" + line[3:].strip()\n        elif line.startswith(\".. \"):\n            if short_description is not None:\n                if long_description is not None:\n                    raise ParseError(\n                        \"Docstring has both short and long description.\"\n                    )\n                long_description = short_description\n                short_description = None\n            if long_description is None:\n                long_description = line[3:].strip()\n            else:\n                if line.startswith(\" \"):\n                    long_description += \" \" + line[3:].strip()\n                else:\n                    long_description += \"\\n\" + line[3:].strip()\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                if long_description is not None:\n                    raise ParseError(\n                        \"Docstring has both short and long description.\"\n                    )\n                long_description = short_description\n                short_description = None\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 168, in <module>\n  File \"<string>\", line 167, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 8, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if not lines:\n        raise ParseError(\"Docstring is empty.\")\n    if lines[0].startswith(\".. \"):\n        lines = lines[1:]\n    if lines[-1].endswith(\".\"):\n        lines = lines[:-1]\n    if lines[-1].endswith(\"..\"):\n        lines = lines[:-1]\n    if lines[-1].endswith(\"\\n\"):\n        lines = lines[:-1]\n    if lines[0].startswith(\".. \"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines[1:]\n    if lines[0].startswith(\".. \") and lines[0].endswith(\"\\n\"):\n        lines = lines", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 153, in <module>\n  File \"<string>\", line 152, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 9, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if short_description is not None:\n                raise ParseError(\n                    \"Docstring has blank lines after short description.\"\n                )\n            if long_description is not None:\n                raise ParseError(\n                    \"Docstring has blank lines after long description.\"\n                )\n            if not blank_after_short_description:\n                raise ParseError(\n                    \"Docstring has blank lines after short description.\"\n                )\n            if not blank_after_long_description:\n                raise ParseError(\n                    \"Docstring has blank lines after long description.\"\n                )\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Docstring has multiple short descriptions.\"\n                )\n            if long_description is not None:\n                raise ParseError(\n                    \"Docstring has multiple long descriptions.\"\n                )\n            short_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Docstring has multiple long descriptions.\"\n                )\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Docstring has multiple short descriptions.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Docstring has multiple long descriptions.\"\n            )\n        if line.startswith(\"..", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 168\n    if line.startswith(\"..\n                       ^\nSyntaxError: unterminated string literal (detected at line 168)\n", "passed": false}
{"task_id": 194, "prediction_id": 10, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    deprecated = None  # type: T.Optional[DocstringDeprecated]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if blank_after_short_description:\n                blank_after_short_description = False\n                continue\n            if blank_after_long_description:\n                blank_after_long_description = False\n                continue\n            if returns:\n                returns.description += \"\\n\"\n                continue\n            if deprecated:\n                deprecated.description += \"\\n\"\n                continue\n            if short_description:\n                short_description += \"\\n\"\n                continue\n            if long_description:\n                long_description += \"\\n\"\n                continue\n            raise ParseError(\"Unexpected blank line.\")\n        if line.startswith(\".. \"):\n            if short_description:\n                raise ParseError(\"Unexpected blank line.\")\n            short_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if long_description:\n                raise ParseError(\"Unexpected blank line.\")\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            raise ParseError(\"Unexpected blank line.\")\n        if line.startswith(\".. \"):\n            raise ParseError(\"Unexpected blank line.\")\n        if line.startswith(\".. \"):\n            raise ParseError(\"Unexpected blank line.\")\n        if line.startswith(\".. \"):\n            raise ParseError(\"Unexpected blank line.\")\n        if line.startswith(\"..", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 163\n    if line.startswith(\"..\n                       ^\nSyntaxError: unterminated string literal (detected at line 163)\n", "passed": false}
{"task_id": 194, "prediction_id": 11, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.startswith(\".. _\"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Found multiple short descriptions in a docstring.\"\n                )\n            short_description = line[6:].strip()\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Found multiple long descriptions in a docstring.\"\n                )\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is not None:\n            raise ParseError(\n                \"Found a short description after a long description.\"\n            )\n        elif line.startswith(\".. \") and long_description is not None:\n            raise ParseError(\n                \"Found a long description after a short description.\"\n            )\n        elif line.startswith(\".. \") and short_description is None:\n            raise ParseError(\n                \"Found a short description before a long description.\"\n            )\n        elif line.startswith(\".. \") and long_description is None:\n            raise ParseError(\n                \"Found a long description before a short description.\"\n            )\n        elif line.startswith(\".. \") and short_description is not None:\n            meta.append(_build_meta(line.split(), short_description))\n            short_description = None\n        elif line.startswith(\".. \") and long_description is not None:\n            meta.append(_build_meta(line.split(), long_description))\n            long_description = None\n        elif line.startswith(\".. \") and short_description is None:\n            meta.append(_build_meta(line.split(), long_description))\n            long_description = None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 162, in <module>\n  File \"<string>\", line 161, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 12, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if not lines:\n        raise ParseError(\"Docstring is empty.\")\n    meta = []  # type: T.List[DocstringMeta]\n    description = None  # type: T.Optional[str]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.startswith(\".. \"):\n            if description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=description))\n            description = line[3:].strip()\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=short_description))\n            short_description = None\n            long_description = None\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=long_description))\n            long_description = line[3:].strip()\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=short_description))\n            short_description = None\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=short_description))\n            short_description = line[4:].strip()\n        elif line.startswith(\"    \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=long_description))\n            long_description = line[4:].strip()\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=short_description))\n            short_description = line[4:].strip()\n        elif line.startswith(\"    \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 152\n    meta.append(DocstringMeta(args=[\"\n                                    ^\nSyntaxError: unterminated string literal (detected at line 152)\n", "passed": false}
{"task_id": 194, "prediction_id": 13, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if short_description is not None:\n                if not blank_after_short_description:\n                    raise ParseError(\n                        \"Expected blank line after short description.\"\n                    )\n                blank_after_short_description = False\n            if long_description is not None:\n                if not blank_after_long_description:\n                    raise ParseError(\n                        \"Expected blank line after long description.\"\n                    )\n                blank_after_long_description = False\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                if not blank_after_short_description:\n                    raise ParseError(\n                        \"Expected blank line after short description.\"\n                    )\n                blank_after_short_description = False\n            if long_description is not None:\n                if not blank_after_long_description:\n                    raise ParseError(\n                        \"Expected blank line after long description.\"\n                    )\n                blank_after_long_description = False\n            short_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                if not blank_after_long_description:\n                    raise ParseError(\n                        \"Expected blank line after long description.\"\n                    )\n                blank_after_long_description = False\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                if not", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 164\n    if not\n          ^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 194, "prediction_id": 14, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    description = None  # type: T.Optional[str]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if description is not None:\n                meta.append(DocstringMeta(args=[], description=description))\n                description = None\n                short_description = None\n                long_description = None\n                blank_after_short_description = False\n                blank_after_long_description = False\n            continue\n        if line.startswith(\"..\"):\n            if description is not None:\n                meta.append(DocstringMeta(args=[], description=description))\n                description = None\n                short_description = None\n                long_description = None\n                blank_after_short_description = False\n                blank_after_long_description = False\n            continue\n        if description is None:\n            if line.startswith(\".. \"):\n                description = line[3:]\n                continue\n            if line.startswith(\" \"):\n                if short_description is None:\n                    short_description = line\n                    continue\n                if long_description is None:\n                    long_description = line\n                    continue\n            raise ParseError(\"Expected description.\")\n        if short_description is not None:\n            if line.startswith(\" \"):\n                short_description += line\n                continue\n            if line.startswith(\" \") and not blank_after_short_description:\n                raise ParseError(\"Expected blank after short description.\")\n            if line.startswith(\" \") and blank_after_short_description:\n                continue\n            if line.startswith(\" \") and blank_after_long_description:\n                continue\n            if line.startswith(\" \") and not blank_after_long_description:\n                raise ParseError(\"Expected blank after long description.\")\n            if line.startsw", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 164\n    if line.startsw\n                   ^\nSyntaxError: expected ':'\n", "passed": false}
{"task_id": 194, "prediction_id": 15, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_lines = []  # type: T.List[str]\n    param_args = []  # type: T.List[str]\n    param_desc = []  # type: T.List[str]\n    param_type = []  # type: T.List[str]\n    param_is_optional = []  # type: T.List[bool]\n    param_default = []  # type: T.List[str]\n    param_arg_name = []  # type: T.List[str]\n    param_type_name = []  # type: T.List[str]\n    param_description = []  # type: T.List[str]\n    param_is_generator = []  # type: T.List[bool]\n    param_raises = []  # type: T.List[str]\n    param_raises_type = []  # type: T.List[str]\n    param_raises_description = []  # type: T.List[str]\n    param_raises_is_generator = []  # type: T.List[bool]\n    param_raises_default = []  # type: T.List[str]\n    param_raises_arg_name = []  # type: T.List[str]\n    param_raises_type_name = []  # type: T.List[str]\n    param_raises_description = []  # type: T.List[str]\n    param_raises_is_generator = []  # type: T.List[bool]\n    param_raises_default = []  # type: T.List[str]\n    param_raises_arg_name = []  # type: T.List[str]\n    param_raises_type_name = []  # type: T.List[str]\n    param_raises_description = []  # type: T.List[str]\n    param_raises_is_generator = []  # type: T.List[bool]\n    param_raises_default = []  #", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 145, in <module>\n  File \"<string>\", line 144, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 16, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    desc = \"\"\n    for line in lines:\n        if line.startswith(\".. \"):\n            if desc:\n                meta.append(_build_meta(meta, desc))\n                desc = \"\"\n            meta.append(_build_meta(line[3:].split(), \"\"))\n        elif line.startswith(\".. \") and desc:\n            meta.append(_build_meta(meta, desc))\n            desc = \"\"\n        elif desc:\n            desc += line\n        else:\n            desc += line\n    if desc:\n        meta.append(_build_meta(meta, desc))\n    return Docstring(meta=meta)\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 138, in <module>\n  File \"<string>\", line 137, in test_21\n  File \"<string>\", line 130, in parse\n  File \"<string>\", line 44, in _build_meta\nIndexError: list index out of range\n", "passed": false}
{"task_id": 194, "prediction_id": 17, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    deprecated = None  # type: T.Optional[DocstringDeprecated]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\"Found multiple short descriptions.\")\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\"Found multiple long descriptions.\")\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is not None:\n            raise ParseError(\"Found short description after long description.\")\n        elif line.startswith(\".. \") and long_description is not None:\n            raise ParseError(\"Found long description after short description.\")\n        elif line.startswith(\".. \") and short_description is None:\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \") and long_description is None:\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is not None:\n            if not line.endswith(\".\"):\n                raise ParseError(\"Short description must end with a period.\")\n            if blank_after_short_description:\n                raise ParseError(\"Found blank line after short description.\")\n            blank_after_short_description = True\n        elif line.startswith(\".. \") and long_description is not None:\n            if not line.endswith(\".\"):\n                ", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 151\n    import pickle\nIndentationError: expected an indented block after 'if' statement on line 147\n", "passed": false}
{"task_id": 194, "prediction_id": 18, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Found multiple short descriptions in docstring.\"\n                )\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Found multiple long descriptions in docstring.\"\n                )\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is None:\n            raise ParseError(\n                \"Found short description without a preceding long description.\"\n            )\n        elif line.startswith(\".. \") and long_description is None:\n            raise ParseError(\n                \"Found long description without a preceding short description.\"\n            )\n        elif line.startswith(\".. \") and short_description is not None:\n            if long_description is not None:\n                raise ParseError(\n                    \"Found short description without a preceding long description.\"\n                )\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and long_description is not None:\n            if short_description is not None:\n                raise ParseError(\n                    \"Found long description without a preceding short description.\"\n                )\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is None and long_description is None:\n            raise ParseError(\n                \"Found short description without", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 157\n    \"Found short description without\n    ^\nSyntaxError: unterminated string literal (detected at line 157)\n", "passed": false}
{"task_id": 194, "prediction_id": 19, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if len(lines) == 0:\n        raise ParseError(\"Docstring is empty.\")\n    if lines[0].strip() != \"\":\n        raise ParseError(\"Docstring should start with an empty line.\")\n    if lines[-1].strip() != \"\":\n        raise ParseError(\"Docstring should end with an empty line.\")\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    meta = []  # type: T.List[DocstringMeta]\n    for line in lines[1:-1]:\n        line = line.strip()\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\"Docstring should not have multiple short descriptions.\")\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\"Docstring should not have multiple long descriptions.\")\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Docstring should not have multiple short descriptions.\")\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Docstring should not have multiple long descriptions.\")\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Docstring should not have multiple short descriptions.\")\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Docstring should not have multiple long descriptions.\")\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Docstring should not have multiple short descriptions.\")\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Docstring should not have multiple long descriptions.\")\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Docstring should not have multiple short descriptions.\")\n        elif line.startswith(\".. \"):\n            raise ParseError(\"Docstring should not have multiple long descriptions.\")\n        elif line.startswith(\".. \"):\n            raise ParseError", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 156, in <module>\n  File \"<string>\", line 155, in test_21\n  File \"<string>\", line 117, in parse\ndocstring_parser.common.ParseError: Docstring should start with an empty line.\n", "passed": false}
{"task_id": 194, "prediction_id": 20, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.strip() == \"\":\n            blank_after_short_description = True\n            blank_after_long_description = True\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Found multiple short descriptions in docstring.\"\n                )\n            short_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Found multiple long descriptions in docstring.\"\n                )\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a long description in docstring.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a short description in docstring.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a parameter in docstring.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a return in docstring.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a raise in docstring.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found a description after a deprecated in docstring.\"\n            )\n        if line", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 165\n    if line\n           ^\nSyntaxError: expected ':'\n", "passed": false}
{"task_id": 194, "prediction_id": 21, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if not lines:\n        return Docstring()\n    meta = []  # type: T.List[DocstringMeta]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=short_description))\n                short_description = None\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=long_description))\n                long_description = None\n            meta.append(_build_meta(line[3:].split(), \".. \"))\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=short_description))\n                short_description = None\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=long_description))\n                long_description = None\n            meta.append(_build_meta(line[4:].split(), \"    \"))\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=short_description))\n                short_description = None\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=long_description))\n                long_description = None\n            meta.append(_build_meta(line[4:].split(), \"    \"))\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=short_description))\n                short_description = None\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\"\"], description=long_description))\n                long_description = None\n            meta", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 159, in <module>\n  File \"<string>\", line 158, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 22, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_desc = []  # type: T.List[str]\n    param_args = []  # type: T.List[str]\n    param_type = None  # type: T.Optional[str]\n    param_is_optional = None  # type: T.Optional[bool]\n    param_default = None  # type: T.Optional[str]\n    param_arg_name = None  # type: T.Optional[str]\n    param_description = None  # type: T.Optional[str]\n    param_type_name = None  # type: T.Optional[str]\n    param_is_generator = False  # type: T.Optional[bool]\n    param_is_generator_type = False  # type: T.Optional[bool]\n    param_is_generator_name = None  # type: T.Optional[str]\n    param_is_generator_default = None  # type: T.Optional[str]\n    param_is_generator_arg_name = None  # type: T.Optional[str]\n    param_is_generator_arg_name_optional = None  # type: T.Optional[bool]\n    param_is_generator_arg_name_default = None  # type: T.Optional[str]\n    param_is_generator_arg_name_optional = None  # type: T.Optional[bool]\n    param_is_generator_arg_name_default = None  # type: T.Optional[str]\n    param_is_generator_arg_name_optional = None  # type: T.Optional[bool]\n    param_is_generator_arg_name_default = None  # type: T.Optional[str]\n    param_is_generator_arg_name_optional = None  # type: T.Optional[bool]\n    param_is_generator_arg_name_default = None  # type: T.Optional[str]\n    param_is_generator_arg_name_optional = None  # type: T.Optional[bool]", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 142, in <module>\n  File \"<string>\", line 141, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 23, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    desc = []  # type: T.List[str]\n    for line in lines:\n        if line.startswith(\".. \"):\n            if desc:\n                meta.append(_build_meta(desc, \"\".join(desc)))\n                desc = []\n            meta.append(_build_meta(line[3:].split(), \"\".join(desc)))\n        else:\n            desc.append(line)\n    if desc:\n        meta.append(_build_meta(desc, \"\".join(desc)))\n    return Docstring(meta)\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 133, in <module>\n  File \"<string>\", line 132, in test_21\n  File \"<string>\", line 126, in parse\nTypeError: Docstring.__init__() takes 1 positional argument but 2 were given\n", "passed": false}
{"task_id": 194, "prediction_id": 24, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    description = None  # type: T.Optional[str]\n    for line in lines:\n        if line.startswith(\".. \"):\n            if description:\n                meta.append(_build_meta(meta, description))\n                description = None\n            meta.append(_build_meta(line[3:].split(), \"\"))\n        elif line.startswith(\".. \") and description is None:\n            description = line[3:]\n        elif line.startswith(\".. \") and description is not None:\n            meta.append(_build_meta(meta, description))\n            description = None\n        elif line.startswith(\"    \"):\n            if description is None:\n                raise ParseError(\"Expected description after '.. '.\")\n            meta.append(_build_meta(meta, description))\n            description = None\n        else:\n            description = line\n    if description is not None:\n        meta.append(_build_meta(meta, description))\n    return Docstring(meta=meta)\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 143, in <module>\n  File \"<string>\", line 142, in test_21\n  File \"<string>\", line 135, in parse\n  File \"<string>\", line 44, in _build_meta\nIndexError: list index out of range\n", "passed": false}
{"task_id": 194, "prediction_id": 25, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_desc = None  # type: T.Optional[str]\n    param_args = []  # type: T.List[str]\n    param_type = None  # type: T.Optional[str]\n    param_is_optional = None  # type: T.Optional[bool]\n    param_default = None  # type: T.Optional[str]\n    param_arg_name = None  # type: T.Optional[str]\n    param_type_name = None  # type: T.Optional[str]\n    param_is_generator = False\n    param_is_generator_type = False\n    param_is_generator_name = None  # type: T.Optional[str]\n    param_is_generator_default = None  # type: T.Optional[str]\n    param_is_generator_type_name = None  # type: T.Optional[str]\n    param_is_generator_default_name = None  # type: T.Optional[str]\n    param_is_generator_type_default = None  # type: T.Optional[str]\n    param_is_generator_default_type = None  # type: T.Optional[str]\n    param_is_generator_type_default_type_name = None  # type: T.Optional[str]\n    param_is_generator_default_type_name_name = None  # type: T.Optional[str]\n    param_is_generator_default_type_name_default = None  # type: T.Optional[str]\n    param_is_generator_type_default_type_name_default_name = None  # type: T.Optional[str]\n    param_is_generator_type_default_type_name_default_type_name = None  # type: T.Optional[str]\n    param_is_generator_type_default_type_name_default_type_name_name = None  # type: T.Optional[str]\n    param_is_generator_type_default_", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 142, in <module>\n  File \"<string>\", line 141, in test_21\n  File \"<string>\", line 136, in parse\nNameError: name 'param_is_generator_type_default_' is not defined. Did you mean: 'param_is_generator_type_default'?\n", "passed": false}
{"task_id": 194, "prediction_id": 26, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if not blank_after_short_description:\n                short_description = None\n            if not blank_after_long_description:\n                long_description = None\n            blank_after_short_description = True\n            blank_after_long_description = True\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Short description should not be followed by a blank line.\"\n                )\n            if long_description is not None:\n                raise ParseError(\n                    \"Long description should not be followed by a blank line.\"\n                )\n            short_description = line[3:].strip()\n            long_description = None\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Long description should not be followed by a blank line.\"\n                )\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Short description should not be followed by a blank line.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Long description should not be followed by a blank line.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Short description should not be followed by a blank line.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 164\n    raise ParseError(\n                    ^\nSyntaxError: '(' was never closed\n", "passed": false}
{"task_id": 194, "prediction_id": 27, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    description = None  # type: T.Optional[str]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.startswith(\".. \"):\n            if description is not None:\n                meta.append(DocstringMeta(args=[], description=description))\n            description = line[3:].strip()\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[], description=short_description))\n            short_description = None\n            long_description = None\n        elif line.startswith(\".. \") and short_description is not None:\n            meta.append(DocstringMeta(args=[], description=short_description))\n            short_description = None\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[], description=short_description))\n            short_description = line[4:].strip()\n        elif line.startswith(\"    \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[], description=long_description))\n            long_description = line[4:].strip()\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[], description=short_description))\n            short_description = line[4:].strip()\n        elif line.startswith(\"    \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[], description=long_description))\n            long_description = line[4:].strip()\n        elif line.startswith(\"    \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[], description=short_description))\n            short_description = line[", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 151\n    short_description = line[\n                            ^\nSyntaxError: '[' was never closed\n", "passed": false}
{"task_id": 194, "prediction_id": 28, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if short_description is not None:\n                if not blank_after_short_description:\n                    short_description += \"\\n\"\n                blank_after_short_description = True\n            if long_description is not None:\n                if not blank_after_long_description:\n                    long_description += \"\\n\"\n                blank_after_long_description = True\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                if not blank_after_short_description:\n                    short_description += \"\\n\"\n                blank_after_short_description = True\n            if long_description is not None:\n                if not blank_after_long_description:\n                    long_description += \"\\n\"\n                blank_after_long_description = True\n            short_description = line[3:].strip()\n            long_description = None\n            continue\n        if short_description is not None:\n            if not blank_after_short_description:\n                short_description += \"\\n\"\n                blank_after_short_description = True\n            meta.append(_build_meta(line.split(), short_description))\n            short_description = None\n            continue\n        if long_description is not None:\n            if not blank_after_long_description:\n                long_description += \"\\n\"\n                blank_after_long_description = True\n            meta.append(_build_meta(line.split(), long_description))\n            long_description = None\n            continue\n        if line.startswith(\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 160\n    if line.startswith(\"\n                       ^\nSyntaxError: unterminated string literal (detected at line 160)\n", "passed": false}
{"task_id": 194, "prediction_id": 29, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    current_meta = []  # type: T.List[DocstringMeta]\n    current_desc = \"\"  # type: T.Optional[str]\n    current_param = None  # type: T.Optional[DocstringParam]\n    current_return = None  # type: T.Optional[DocstringReturns]\n    current_raise = None  # type: T.Optional[DocstringRaises]\n    current_deprecated = None  # type: T.Optional[DocstringDeprecated]\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if current_desc:\n                current_desc += \"\\n\"\n            if current_param:\n                current_param.description += \"\\n\"\n            if current_return:\n                current_return.description += \"\\n\"\n            if current_raise:\n                current_raise.description += \"\\n\"\n            if current_deprecated:\n                current_deprecated.description += \"\\n\"\n            current_meta.append(DocstringMeta(args=current_meta, description=current_desc))\n            current_meta = []\n            current_desc = None\n            current_param = None\n            current_return = None\n            current_raise = None\n            current_deprecated = None\n            continue\n        if line.startswith(\".. \"):\n            if current_desc:\n                current_desc += \"\\n\"\n            current_meta.append(DocstringMeta(args=current_meta, description=current_desc))\n            current_meta = []\n            current_desc = line[3:].strip()\n            continue\n        if line.startswith(\".. \") and current_desc:\n            current_desc += \"\\n\"\n            continue\n        if line.startswith(\".. \"):\n            current_desc = line[3:].strip()\n            continue\n        if line.startswith(\".. \") and current_param:\n            current_param.description += \"\\n\"\n            continue\n        if line.startswith(\".. \") and current_return:\n            current_return.description += \"\\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 159\n    current_return.description += \"\\n\n                                  ^\nSyntaxError: unterminated string literal (detected at line 159)\n", "passed": false}
{"task_id": 194, "prediction_id": 30, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    description = []  # type: T.List[str]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if not line.strip():\n            if short_description is not None:\n                description.append(line)\n            elif long_description is not None:\n                description.append(line)\n            else:\n                raise ParseError(\"Empty docstring.\")\n            continue\n        if short_description is None:\n            if line.startswith(\".. \"):\n                short_description = line[3:].strip()\n            else:\n                raise ParseError(\"Expected a short description.\")\n        elif long_description is None:\n            if line.startswith(\".. \"):\n                long_description = line[3:].strip()\n            else:\n                raise ParseError(\"Expected a long description.\")\n        else:\n            if line.startswith(\".. \"):\n                if blank_after_short_description:\n                    raise ParseError(\"Empty line after short description.\")\n                if blank_after_long_description:\n                    raise ParseError(\"Empty line after long description.\")\n                blank_after_short_description = True\n                blank_after_long_description = True\n                description.append(line)\n            else:\n                if blank_after_short_description:\n                    description.append(line)\n                else:\n                    raise ParseError(\"Empty line after short description.\")\n                if blank_after_long_description:\n                    description.append(line)\n                else:\n                    raise ParseError(\"Empty line after long description.\")\n                meta.append(_build_meta(line.split(), short_description))\n                short_description = None\n                long_description = None\n                blank_after_short_description = False\n                blank_after_long_description = False\n    if short_description is not None:\n        description.append(short_", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 163\n    description.append(short_\n                      ^\nSyntaxError: '(' was never closed\n", "passed": false}
{"task_id": 194, "prediction_id": 31, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if not lines:\n        return Docstring()\n    short_description = None\n    long_description = None\n    meta = []\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if short_description is not None:\n                if long_description is None:\n                    long_description = short_description\n                else:\n                    long_description += \"\\n\"\n                    if not meta:\n                        meta.append(DocstringMeta(args=[\"\"], description=\"\"))\n                    meta.append(DocstringMeta(args=[\"\"], description=\"\"))\n                    long_description += \"\\n\"\n            if short_description is not None:\n                if long_description is None:\n                    long_description = short_description\n                else:\n                    long_description += \"\\n\"\n            if short_description is None:\n                short_description = line\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                if long_description is None:\n                    long_description = short_description\n                else:\n                    long_description += \"\\n\"\n                    if not meta:\n                        meta.append(DocstringMeta(args=[\"\"], description=\"\"))\n                    meta.append(DocstringMeta(args=[\"\"], description=\"\"))\n                    long_description += \"\\n\"\n            short_description = line[3:]\n            continue\n        if short_description is None:\n            raise ParseError(\"No description found.\")\n        if long_description is not None:\n            long_description += \"\\n\"\n        if line.startswith(\".. \"):\n            continue\n        if line.startswith(\".. \") and short_description is not None:\n            raise ParseError(\"Multiple descriptions found.\")\n        if line.startswith(\".. \"):\n            if long_description is None:\n                long_description = short_description\n            else:\n                long_description += \"\\n\"\n                if not meta:\n                    meta.append(DocstringMeta(args=[\"\"], description=\"\"))\n                meta.append(DocstringMeta(args=[\"\"], description=\"\"))\n                long_description += \"\\n\"\n            short_description = line[3", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 168\n    short_description = line[3\n                            ^\nSyntaxError: '[' was never closed\n", "passed": false}
{"task_id": 194, "prediction_id": 32, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_lines = []  # type: T.List[str]\n    param_args = []  # type: T.List[T.List[str]]\n    param_descs = []  # type: T.List[str]\n    param_defaults = []  # type: T.List[str]\n    param_is_optional = []  # type: T.List[bool]\n    param_is_generator = []  # type: T.List[bool]\n    param_type_names = []  # type: T.List[T.Optional[str]]\n    param_arg_names = []  # type: T.List[T.Optional[str]]\n    param_type_names_generators = []  # type: T.List[T.Optional[str]]\n    param_arg_names_generators = []  # type: T.List[T.Optional[str]]\n    param_defaults_generators = []  # type: T.List[T.Optional[str]]\n    param_is_generator = []  # type: T.List[bool]\n    param_is_optional = []  # type: T.List[bool]\n    param_type_names_optional = []  # type: T.List[T.Optional[str]]\n    param_arg_names_optional = []  # type: T.List[T.Optional[str]]\n    param_defaults_optional = []  # type: T.List[T.Optional[str]]\n    param_is_generator_optional = []  # type: T.List[bool]\n    param_is_optional_generator = []  # type: T.List[bool]\n    param_type_names_generators_optional = []  # type: T.List[T.Optional[str]]\n    param_arg_names_generators_optional = []  # type: T.List[T.Optional[str]]\n    param_defaults_generators_optional = []  # type: T.List[T.Optional[str]]\n    param_is_generator_optional", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 142, in <module>\n  File \"<string>\", line 141, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 33, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if len(lines) < 2:\n        raise ParseError(\"Docstring must have at least two lines.\")\n    short_description = lines[0].strip()\n    if not short_description:\n        raise ParseError(\"Docstring must have a short description.\")\n    if not lines[1].strip():\n        raise ParseError(\"Docstring must have a long description.\")\n    if lines[1].startswith(\".. \"):\n        lines[1] = lines[1][3:]\n    meta = []  # type: T.List[DocstringMeta]\n    for line in lines[1:]:\n        if not line.strip():\n            if not meta:\n                raise ParseError(\"Docstring must have a blank line after description.\")\n            if not meta[-1].description:\n                raise ParseError(\"Docstring must have a blank line after description.\")\n            if meta[-1].description.endswith(\".\"):\n                meta[-1].description = meta[-1].description[:-1]\n                meta[-1].blank_after_short_description = True\n            if meta[-1].description.endswith(\"..\"):\n                meta[-1].description = meta[-1].description[:-2]\n                meta[-1].blank_after_long_description = True\n            continue\n        if line.startswith(\".. \"):\n            if meta:\n                raise ParseError(\"Docstring must have a blank line after description.\")\n            meta.append(_build_meta(line.split(), short_description))\n            continue\n        if line.startswith(\".. \"):\n            raise ParseError(\"Docstring must have a blank line after description.\")\n        if line.startswith(\".. \"):\n            raise ParseError(\"Docstring must have a blank line after description.\")\n        if line.startswith(\".. \"):\n            raise ParseError(\"Docstring must have a blank line after description.\")\n        if line.startswith(\".. \"):\n            raise ParseError(\"Docstring must have a blank line after description.\")\n        if line.startswith(\".. \"):\n            raise ParseError(\"Docstring must have a blank line after", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 151\n    raise ParseError(\"Docstring must have a blank line after\n                     ^\nSyntaxError: unterminated string literal (detected at line 151)\n", "passed": false}
{"task_id": 194, "prediction_id": 34, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if not blank_after_short_description:\n                short_description = None\n            if not blank_after_long_description:\n                long_description = None\n            continue\n        if short_description is None:\n            if line.startswith(\".. _\"):\n                short_description = line[4:].strip()\n            else:\n                raise ParseError(\"Expected short description.\")\n        if long_description is None:\n            if line.startswith(\".. _\"):\n                long_description = line[4:].strip()\n            else:\n                raise ParseError(\"Expected long description.\")\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\"Expected blank line after short description.\")\n            if long_description is not None:\n                raise ParseError(\"Expected blank line after long description.\")\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\"Expected blank line after short description.\")\n            if long_description is not None:\n                raise ParseError(\"Expected blank line after long description.\")\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\"Expected blank line after short description.\")\n            if long_description is not None:\n                raise ParseError(\"Expected blank line after long description.\")\n            continue\n        if line.startswith(\".. \"):\n            if short_", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 159\n    if short_\n             ^\nSyntaxError: expected ':'\n", "passed": false}
{"task_id": 194, "prediction_id": 35, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    description = \"\"\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if description:\n                meta.append(_build_meta(meta, description))\n                description = \"\"\n        elif line.startswith(\".. \"):\n            if description:\n                meta.append(_build_meta(meta, description))\n                description = \"\"\n            meta.append(_build_meta([line[3:]], \"\"))\n        elif description:\n            description += line + \"\\n\"\n        else:\n            raise ParseError(\"Expected description or keyword.\")\n    if description:\n        meta.append(_build_meta(meta, description))\n    return Docstring(meta=meta)\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 140, in <module>\n  File \"<string>\", line 139, in test_21\n  File \"<string>\", line 130, in parse\ndocstring_parser.common.ParseError: Expected description or keyword.\n", "passed": false}
{"task_id": 194, "prediction_id": 36, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_desc = None  # type: T.Optional[str]\n    param_args = []  # type: T.List[str]\n    param_type_name = None  # type: T.Optional[str]\n    param_is_optional = None  # type: T.Optional[bool]\n    param_default = None  # type: T.Optional[str]\n    param_arg_name = None  # type: T.Optional[str]\n    param_description = None  # type: T.Optional[str]\n    param_type_name_arg_name = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_description = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_type_name = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_type_name_optional = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_type_name_optional_default = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_type_name_optional_default_description = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_type_name_optional_default_type_name = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_type_name_optional_default_type_name_optional_default = None  # type: T.Optional[str]\n    param_type_name_arg_name_optional_default_type_name_optional_default_type_name_optional_default_description = None  # type:", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 138, in <module>\n  File \"<string>\", line 137, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 37, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if not blank_after_short_description:\n                short_description = None\n            if not blank_after_long_description:\n                long_description = None\n            continue\n        if short_description is None:\n            if line.startswith(\".. \"):\n                short_description = line[3:].strip()\n            else:\n                raise ParseError(\"Expected a short description.\")\n        elif long_description is None:\n            if line.startswith(\".. \"):\n                long_description = line[3:].strip()\n            else:\n                raise ParseError(\"Expected a long description.\")\n        else:\n            if line.startswith(\".. \"):\n                blank_after_short_description = True\n            else:\n                blank_after_long_description = True\n            meta.append(_build_meta(line.split(), short_description))\n            short_description = None\n            long_description = None\n    if short_description is not None:\n        meta.append(_build_meta(line.split(), short_description))\n    if long_description is not None:\n        meta.append(_build_meta(line.split(), long_description))\n    return Docstring(meta=meta)\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 156, in <module>\n  File \"<string>\", line 155, in test_21\n  File \"<string>\", line 131, in parse\ndocstring_parser.common.ParseError: Expected a short description.\n", "passed": false}
{"task_id": 194, "prediction_id": 38, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    current_meta = []  # type: T.List[DocstringMeta]\n    current_desc = \"\"  # type: T.Optional[str]\n    current_param = None  # type: T.Optional[DocstringParam]\n    current_param_type = None  # type: T.Optional[str]\n    current_param_arg_name = None  # type: T.Optional[str]\n    current_param_is_optional = None  # type: T.Optional[bool]\n    current_param_default = None  # type: T.Optional[str]\n    current_param_type_name = None  # type: T.Optional[str]\n    current_param_type_name_is_optional = None  # type: T.Optional[bool]\n    current_param_type_name_is_generator = None  # type: T.Optional[bool]\n    current_param_type_name_is_generator_or_optional = None  # type: T.Optional[bool]\n    current_param_type_name_is_generator_or_optional_is_optional = None  # type: T.Optional[bool]\n    current_param_type_name_is_generator_or_optional_is_generator = None  # type: T.Optional[bool]\n    current_param_type_name_is_generator_or_optional_is_generator_or_optional = None  # type: T.Optional[bool]\n    current_param_type_name_is_generator_or_optional_is_generator_or_optional_is_generator = None  # type: T.Optional[bool]\n    current_param_type_name_is_generator_or_optional_is_generator_or_optional_is_generator_or_optional_is_generator = None  # type: T.Optional[bool]\n    current_param_type_name_is_generator_or_optional_is_generator_or_optional_is_generator_or_optional_is_generator_or_", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 137, in <module>\n  File \"<string>\", line 136, in test_21\n  File \"<string>\", line 131, in parse\nNameError: name 'current_param_type_name_is_generator_or_optional_is_generator_or_optional_is_generator_or_optional_is_generator_or_' is not defined\n", "passed": false}
{"task_id": 194, "prediction_id": 39, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if not lines:\n        return Docstring()\n    meta = []  # type: T.List[DocstringMeta]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                meta.append(DocstringMeta(args=[\".. \"], description=short_description))\n            short_description = line[3:].strip()\n            if short_description.endswith(\".\"):\n                blank_after_short_description = True\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                meta.append(DocstringMeta(args=[\".. \"], description=long_description))\n            long_description = line[3:].strip()\n            if long_description.endswith(\".\"):\n                blank_after_long_description = True\n            continue\n        if short_description is not None:\n            meta.append(_build_meta(line.split(), short_description))\n            short_description = None\n        if long_description is not None:\n            meta.append(_build_meta(line.split(), long_description))\n            long_description = None\n    if short_description is not None:\n        meta.append(_build_meta(line.split(), short_description))\n    if long_description is not None:\n        meta.append(_build_meta(line.split(), long_description))\n    if blank_after_short_description:\n        meta.append(DocstringMeta(args=[\"\"], description=None))\n    if blank_after_long_description:\n        meta.append(DocstringMeta(args=[\"\"], description=None))\n    return Docstring(meta=meta)\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 158, in <module>\n  File \"<string>\", line 157, in test_21\n  File \"<string>\", line 151, in parse\nTypeError: Docstring.__init__() got an unexpected keyword argument 'meta'\n", "passed": false}
{"task_id": 194, "prediction_id": 40, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if short_description is not None:\n                raise ParseError(\n                    \"Expected blank line after short description.\"\n                )\n            if long_description is not None:\n                raise ParseError(\n                    \"Expected blank line after long description.\"\n                )\n            if blank_after_short_description:\n                raise ParseError(\n                    \"Expected blank line after short description.\"\n                )\n            if blank_after_long_description:\n                raise ParseError(\n                    \"Expected blank line after long description.\"\n                )\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Expected blank line after short description.\"\n                )\n            if long_description is not None:\n                raise ParseError(\n                    \"Expected blank line after long description.\"\n                )\n            short_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Expected blank line after long description.\"\n                )\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Expected blank line after short description.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Expected blank line after long description.\"\n            )\n        if line.startswith(\".. \"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 168\n    if line.startswith(\".. \"\n                      ^\nSyntaxError: '(' was never closed\n", "passed": false}
{"task_id": 194, "prediction_id": 41, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Found a short description after a long description.\"\n                )\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Found a long description after a short description.\"\n                )\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is None:\n            raise ParseError(\n                \"Found a short description without a long description.\"\n            )\n        elif line.startswith(\".. \") and long_description is None:\n            raise ParseError(\n                \"Found a long description without a short description.\"\n            )\n        elif line.startswith(\".. \") and short_description is not None:\n            if long_description is not None:\n                raise ParseError(\n                    \"Found a short description after a long description.\"\n                )\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and long_description is not None:\n            if short_description is not None:\n                raise ParseError(\n                    \"Found a long description after a short description.\"\n                )\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is None:\n            raise ParseError(\n                \"Found a short description without a long description", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 157\n    \"Found a short description without a long description\n    ^\nSyntaxError: unterminated string literal (detected at line 157)\n", "passed": false}
{"task_id": 194, "prediction_id": 42, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_lines = []  # type: T.List[str]\n    param_args = []  # type: T.List[str]\n    param_desc = []  # type: T.List[str]\n    param_type = None  # type: T.Optional[str]\n    param_is_optional = None  # type: T.Optional[bool]\n    param_default = None  # type: T.Optional[str]\n    param_arg_name = None  # type: T.Optional[str]\n    param_type_name = None  # type: T.Optional[str]\n    param_is_generator = False  # type: T.Optional[bool]\n    param_is_raises = False  # type: T.Optional[bool]\n    param_is_yields = False  # type: T.Optional[bool]\n    param_is_deprecated = False  # type: T.Optional[bool]\n    param_is_raises_or_yields = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_deprecated = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_deprecated_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_deprecated_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_deprecated_or_optional_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_deprecated_or_optional_or_optional_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_deprecated_or_optional_or_optional_or_optional_or_optional_or_optional = False  # type: T.Optional[bool]\n    param", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 140, in <module>\n  File \"<string>\", line 139, in test_21\n  File \"<string>\", line 134, in parse\nNameError: name 'param' is not defined. Did you mean: 'parse'?\n", "passed": false}
{"task_id": 194, "prediction_id": 43, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if len(lines) == 0:\n        raise ParseError(\"Docstring is empty.\")\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 161\n    lines = lines[\n                 ^\nSyntaxError: '[' was never closed\n", "passed": false}
{"task_id": 194, "prediction_id": 44, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    deprecation = None  # type: T.Optional[DocstringDeprecated]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if short_description is not None:\n                raise ParseError(\n                    \"Found blank line after short description.\"\n                )\n            if long_description is not None:\n                raise ParseError(\n                    \"Found blank line after long description.\"\n                )\n            if blank_after_short_description:\n                raise ParseError(\n                    \"Found blank line after short description.\"\n                )\n            if blank_after_long_description:\n                raise ParseError(\n                    \"Found blank line after long description.\"\n                )\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\n                    \"Found short description after '.. '.\"\n                )\n            if long_description is not None:\n                raise ParseError(\n                    \"Found long description after '.. '.\"\n                )\n            short_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\n                    \"Found long description after '.. '.\"\n                )\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found short description after '.. '.\"\n            )\n        if line.startswith(\".. \"):\n            raise ParseError(\n                \"Found long description after '..", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 167\n    \"Found long description after '..\n    ^\nSyntaxError: unterminated string literal (detected at line 167)\n", "passed": false}
{"task_id": 194, "prediction_id": 45, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    param_lines = []  # type: T.List[str]\n    param_args = []  # type: T.List[str]\n    param_desc = []  # type: T.List[str]\n    param_type = None  # type: T.Optional[str]\n    param_is_optional = None  # type: T.Optional[bool]\n    param_default = None  # type: T.Optional[str]\n    param_arg_name = None  # type: T.Optional[str]\n    param_type_name = None  # type: T.Optional[str]\n    param_is_generator = False  # type: T.Optional[bool]\n    param_is_raises = False  # type: T.Optional[bool]\n    param_is_yields = False  # type: T.Optional[bool]\n    param_is_deprecated = False  # type: T.Optional[bool]\n    param_is_raises_or_yields = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_or_deprecated = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_or_deprecated_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_or_deprecated_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_or_deprecated_or_optional_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_or_deprecated_or_optional_or_optional_or_optional_or_optional = False  # type: T.Optional[bool]\n    param_is_raises_or_yields_or_deprecated_or_optional_or_optional_or_optional_or_optional_or_optional = False  ", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 139, in <module>\n  File \"<string>\", line 138, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 46, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                raise ParseError(\"Found multiple short descriptions.\")\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \"):\n            if long_description is not None:\n                raise ParseError(\"Found multiple long descriptions.\")\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is None:\n            raise ParseError(\"Found short description without a long description.\")\n        elif line.startswith(\".. \") and long_description is None:\n            raise ParseError(\"Found long description without a short description.\")\n        elif line.startswith(\".. \") and short_description is not None:\n            if long_description is not None:\n                raise ParseError(\"Found both short and long descriptions.\")\n            long_description = line[3:].strip()\n        elif line.startswith(\".. \") and long_description is not None:\n            if short_description is not None:\n                raise ParseError(\"Found both short and long descriptions.\")\n            short_description = line[3:].strip()\n        elif line.startswith(\".. \") and short_description is None and long_description is None:\n            raise ParseError(\"Found neither short nor long description.\")\n        elif line.startswith(\".. \") and short_description is not None and long_description is not None:\n            if short_description.endswith(\"...\") and long_description.endsw", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 146\n    if short_description.endswith(\"...\") and long_description.endsw\n                                                                   ^\nSyntaxError: expected ':'\n", "passed": false}
{"task_id": 194, "prediction_id": 47, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    params = []  # type: T.List[DocstringParam]\n    raises = []  # type: T.List[DocstringRaises]\n    returns = None  # type: T.Optional[DocstringReturns]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if short_description is not None:\n                if not blank_after_short_description:\n                    short_description += \"\\n\"\n                blank_after_short_description = True\n            if long_description is not None:\n                if not blank_after_long_description:\n                    long_description += \"\\n\"\n                blank_after_long_description = True\n            continue\n        if line.startswith(\".. \"):\n            if short_description is not None:\n                if not blank_after_short_description:\n                    short_description += \"\\n\"\n                blank_after_short_description = True\n            if long_description is not None:\n                if not blank_after_long_description:\n                    long_description += \"\\n\"\n                blank_after_long_description = True\n            short_description = line[3:].strip()\n            continue\n        if line.startswith(\".. \"):\n            if long_description is not None:\n                if not blank_after_long_description:\n                    long_description += \"\\n\"\n                blank_after_long_description = True\n            long_description = line[3:].strip()\n            continue\n        if line.startswith(\"    \"):\n            if short_description is not None:\n                if not blank_after_short_description:\n                    short_description += \"\\n\"\n                blank_after_short_description = True\n            if long_description is not None:\n                if not blank_after_long_description:\n                    long_description += \"\\n\"\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 166, in <module>\n  File \"<string>\", line 165, in test_21\nAttributeError: 'NoneType' object has no attribute 'returns'\n", "passed": false}
{"task_id": 194, "prediction_id": 48, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    meta = []  # type: T.List[DocstringMeta]\n    short_description = None  # type: T.Optional[str]\n    long_description = None  # type: T.Optional[str]\n    blank_after_short_description = False\n    blank_after_long_description = False\n    for line in lines:\n        line = line.strip()\n        if not line:\n            if not blank_after_short_description:\n                short_description = None\n            if not blank_after_long_description:\n                long_description = None\n            blank_after_short_description = True\n            blank_after_long_description = True\n            continue\n        if short_description is None:\n            if line.startswith(\".. \"):\n                short_description = line[3:].strip()\n            else:\n                raise ParseError(\"Expected a short description.\")\n        elif long_description is None:\n            if line.startswith(\".. \"):\n                long_description = line[3:].strip()\n            else:\n                raise ParseError(\"Expected a long description.\")\n        else:\n            if line.startswith(\".. \"):\n                raise ParseError(\"Expected a description after a short description.\")\n            meta.append(_build_meta(line.split(), short_description))\n            short_description = None\n    if short_description is not None:\n        raise ParseError(\"Expected a description after a long description.\")\n    if long_description is not None:\n        raise ParseError(\"Expected a description after a short description.\")\n    return Docstring(meta=meta)\n", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 155, in <module>\n  File \"<string>\", line 154, in test_21\n  File \"<string>\", line 133, in parse\ndocstring_parser.common.ParseError: Expected a short description.\n", "passed": false}
{"task_id": 194, "prediction_id": 49, "generation": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.splitlines()\n    if len(lines) == 0:\n        raise ParseError(\"Docstring is empty.\")\n    if lines[0].strip() == \"\":\n        lines = lines[1:]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1]\n    if lines[-1].strip() == \"\":\n        lines = lines[:-1", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 159\n    lines = lines[:-1\n                 ^\nSyntaxError: '[' was never closed\n", "passed": false}
